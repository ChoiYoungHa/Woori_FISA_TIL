# VM웨어 네트워크 기초(네트워크 4계층, 토폴로지, 서브넷팅)

### 하나의 ITEM이 나왔을 때 이해 프로세스

1. 정의
2. 사용목적
3. 구성(설정) configure (CLI 명령어)
4. 확인

### 네트워크 실습 프로그램

- packet tracer
- gns
- pnetlab
- eve-ng

### 네트워크 통신방식

- NIC 카드 통해 통신
- IP 설계

### 시스코 패킷 트레이서 네트워크 구성

![%ED%99%94%EB%A9%B4_%EC%BA%A1%EC%B2%98_2024-08-19_101315](https://github.com/user-attachments/assets/e26bbbbd-7605-4cfb-8649-1741eb265b3f)


![%ED%99%94%EB%A9%B4_%EC%BA%A1%EC%B2%98_2024-08-19_103719](https://github.com/user-attachments/assets/3fcbff1b-c47b-4b79-8c6a-0fd9493b9c7b)

- 패킷 트레이서로 위와 같이 실제 장비에 포트, 케이블, 장비, cli까지 다 미리 설계해볼 수 있다.

### 인터페이스 케이블

- e : ethernet (10M bps ←- 10*10^6 bit per sec)
- fe : fast ethernet  (100M bps ←- 100*10^6 bit per sec)
- gi : giga ethernet  (1*10^9 bps)
- te : tera ethernet
- bandwidth : 대역폭의 차이

### 네트워크 구조타입

- enterprise 종류 및 특징
    - 내부망, 행정망, 인트라넷
- service provider 종류 및 특징
    - KT, SKT, LG U+
    - 속도, A/S서비스, 안정적인 서비스
- data center 종류
    - 엔터프라이즈 데이터센터
        - 회사 내부망 데이터센터
    - 서비스 프로바이더 데이터센터
        - 사용자들에게 제공하는 통신을 제공하는 데이터센터
- Cloud

### 통신방식

- 장비와 장비
- 장비와 사람
- 사람과 사람
- 각 설정이 다르다. 장비와 장비 switch to switch

### 장비종류

- Hub
- L4-L7 Switch
- IDS : intrusion detection system
- IPS : intrusion prevention system
- WAAS

<aside>
💡 IPS

Intrusion Prevention System(IPS), 즉 침입 방지 시스템은 네트워크 또는 시스템에 대한 불법적인 접근 시도를 실시간으로 탐지하고 차단하는 보안 장치입니다. IPS는 네트워크 보안의 중요한 구성 요소로, 내부망을 외부 위협으로부터 보호하는 데 핵심적인 역할을 합니다.

### 1. **IPS의 기본 개념**

IPS는 일종의 "보안 경비원"으로 생각할 수 있습니다. 이 경비원은 네트워크를 모니터링하며, 의심스러운 활동이나 악의적인 접근 시도를 발견하면 이를 즉시 차단합니다. IPS는 주로 네트워크의 실시간 트래픽을 분석하여, 악의적인 활동이 발생하기 전에 이를 차단함으로써 네트워크를 보호합니다.

### **비유:**

이를 일상적인 상황에 비유해 보겠습니다. 당신의 집을 생각해보세요. 집 안에는 귀중한 물건들이 있고, 이 물건들을 보호하기 위해 보안 시스템을 설치했다고 가정해봅시다. 이 보안 시스템은 누군가가 창문을 통해 들어오려고 할 때 경보를 울리거나, 문을 강제로 열려고 할 때 문을 잠그는 등의 행동을 즉시 수행합니다. IPS는 이와 같은 역할을 네트워크에서 수행합니다. 네트워크에 들어오려는 악의적인 시도를 탐지하고, 그 시도가 성공하기 전에 이를 차단하는 것입니다.

### 2. **IPS의 주요 기능**

- **실시간 트래픽 모니터링**: IPS는 네트워크를 통해 오가는 모든 트래픽을 실시간으로 모니터링합니다. 이 과정에서 정상적인 트래픽과 악성 트래픽을 구별하기 위해 다양한 방법을 사용합니다.
- **패턴 인식**: IPS는 알려진 공격 패턴(시그니처)을 이용해 악의적인 트래픽을 탐지합니다. 이러한 패턴 인식은 바이러스 백신이 악성 코드를 탐지하는 방식과 유사합니다. 특정 공격의 시그니처를 미리 알고 있는 경우, IPS는 해당 시그니처가 포함된 트래픽을 차단합니다.
- **행동 분석**: IPS는 트래픽의 행동을 분석하여, 정상적인 트래픽에서 벗어난 비정상적인 행동을 탐지합니다. 예를 들어, 네트워크에서 갑자기 대량의 데이터가 전송되거나 비정상적인 시간에 접근이 시도되는 경우, 이는 잠재적인 공격으로 간주될 수 있습니다.
- **자동 대응**: IPS는 의심스러운 트래픽을 탐지하면, 이를 자동으로 차단합니다. 이는 방화벽 규칙을 변경하거나, 특정 IP 주소를 블랙리스트에 추가하는 방식으로 이루어질 수 있습니다.

### 3. **IPS와 IDS의 차이점**

IPS는 종종 침입 탐지 시스템(IDS, Intrusion Detection System)과 혼동되기도 합니다. 두 시스템은 유사한 기능을 수행하지만, 중요한 차이점이 있습니다.

- **IDS (Intrusion Detection System)**: IDS는 네트워크나 시스템에서 발생하는 의심스러운 활동을 탐지하고 경고를 보냅니다. 그러나 IDS는 이 활동을 차단하지 않습니다. 경비원이 침입자를 보고 경보를 울리지만, 직접 침입자를 제압하지는 않는 상황과 비슷합니다.
- **IPS (Intrusion Prevention System)**: IPS는 IDS의 기능을 포함하면서, 추가로 공격을 실시간으로 차단합니다. 경비원이 침입자를 보고 경보를 울리는 동시에, 직접 제압하여 집안에 들어오는 것을 막는 역할을 합니다.

### 4. **IPS의 위치와 배치**

IPS는 네트워크 내에서 트래픽이 오가는 경로 중간에 배치됩니다. 이를 **인라인(inline)** 배치라고 하며, IPS는 모든 트래픽을 실시간으로 검사합니다. 만약 악성 트래픽이 탐지되면, IPS는 그 트래픽이 목적지에 도달하기 전에 차단합니다. 이렇게 인라인으로 배치된 IPS는 네트워크의 속도와 성능에 직접적인 영향을 줄 수 있기 때문에, 성능 최적화가 매우 중요합니다.

### 5. **IPS의 종류**

- **네트워크 기반 IPS (NIPS)**: 이 유형의 IPS는 네트워크 전체를 모니터링하고 보호합니다. 주로 네트워크 경계에 배치되어 외부에서 들어오는 공격을 차단합니다.
- **호스트 기반 IPS (HIPS)**: 이 유형의 IPS는 개별 시스템이나 서버에 설치되어, 해당 시스템에 대한 공격을 탐지하고 방지합니다. 시스템 내부의 트래픽과 애플리케이션 활동을 모니터링합니다.

### 6. **현대적 IPS의 발전**

오늘날 IPS는 더욱 지능화되고 자동화된 기능을 갖추고 있습니다. 머신러닝과 인공지능 기술이 도입되어, 새로운 공격 패턴을 학습하고 예측하는 능력이 향상되고 있습니다. 이로 인해 알려지지 않은 새로운 위협에도 더 빠르고 정확하게 대응할 수 있습니다.

### 요약

IPS는 네트워크나 시스템에 대한 불법적인 접근 시도를 실시간으로 탐지하고 차단하는 역할을 하는 보안 장치입니다. 네트워크 트래픽을 모니터링하며, 알려진 패턴과 비정상적인 행동을 분석하여 공격을 막습니다. IDS와 달리, IPS는 경고뿐만 아니라 실제로 공격을 차단하는 능력을 갖추고 있습니다.

</aside>

### 데이터 프레임 구조

- HttpRequest → TCP / IP / ETH  ↔ ETH / IP / TCP / HttpResponse
- Encapsulation (출발지) 소스 → De-Encapsulation (목적지)
- L2 → L3 → L4 → D
    - 이 데이터구조를 확인하는 방법은 와이어 샤크 사용 (LAN카드에 지나가는 데이터를 데이터 프레임 형태로 보여준다)
    - http request wire shark

<aside>
💡 Http Request Wire Shark 예제

HTTP 요청을 Wireshark로 캡처한 데이터를 기반으로 L2, L3, L4의 구조를 설명하는 것은 네트워크 패킷이 어떻게 캡슐화되어 전송되는지를 이해하는 데 매우 중요합니다. 각 계층은 해당 계층의 프로토콜을 포함한 데이터를 캡슐화하고, 이를 다음 계층으로 전달합니다. 이 과정에서 Wireshark는 각 계층의 데이터를 분석해 보여줍니다.

### **1. 계층별 개요**

- **L2 (데이터 링크 계층)**: 이 계층은 네트워크 하드웨어 간의 데이터를 전달하는 역할을 하며, 주로 이더넷 프레임이 이 계층에서 처리됩니다.
- **L3 (네트워크 계층)**: 이 계층에서는 IP 주소를 기반으로 데이터를 목적지까지 라우팅합니다. 주로 IP 패킷이 이 계층에서 다뤄집니다.
- **L4 (전송 계층)**: 이 계층은 데이터 전송을 담당하며, TCP나 UDP 같은 프로토콜이 여기서 사용됩니다. 이 계층은 데이터를 세그먼트로 나누고, 신뢰성 있는 전송을 보장합니다.

### **L2 (데이터 링크 계층) - 이더넷 프레임**

L2 계층에서는 데이터를 **이더넷 프레임**이라는 단위로 처리합니다. 이 계층의 주요 구성 요소는 다음과 같습니다:

- **Destination MAC Address (목적지 MAC 주소)**: 데이터를 받을 장치의 물리적 주소입니다.
- **Source MAC Address (출발지 MAC 주소)**: 데이터를 보내는 장치의 물리적 주소입니다.
- **EtherType**: 상위 계층(즉, L3)의 프로토콜을 나타내는 필드입니다. 예를 들어, 0x0800은 IPv4를 의미합니다.
- **Payload**: 상위 계층(L3)의 데이터가 포함됩니다.
- **Frame Check Sequence (FCS)**: 오류 검출을 위한 필드입니다.

**예시 데이터프레임 구조 (L2):**

| Destination MAC | Source MAC | EtherType | Payload (L3 데이터) | FCS |
| --- | --- | --- | --- | --- |
| 00:11:22:33:44:55 | 66:77:88:99:AA:BB | 0x0800 | (L3 데이터 포함) | (4 bytes) |

### **L3 (네트워크 계층) - IP 패킷**

L3 계층에서는 데이터를 **IP 패킷**으로 처리합니다. 주요 필드는 다음과 같습니다:

- **Version**: 사용 중인 IP의 버전 (IPv4 또는 IPv6).
- **Header Length**: IP 헤더의 길이.
- **Total Length**: IP 패킷 전체의 길이.
- **Source IP Address**: 데이터를 보내는 장치의 IP 주소.
- **Destination IP Address**: 데이터를 받을 장치의 IP 주소.
- **TTL (Time to Live)**: 패킷이 네트워크에서 살아남을 수 있는 시간.
- **Protocol**: 상위 계층(L4)의 프로토콜을 나타냅니다. 예를 들어, 6은 TCP를 의미합니다.
- **Payload**: 상위 계층(L4)의 데이터가 포함됩니다.

**예시 데이터프레임 구조 (L3):**

| Version | Header Length | Total Length | Source IP | Destination IP | TTL | Protocol | Payload (L4 데이터) |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 4 | 20 bytes | 60 bytes | 192.168.0.1 | 192.168.0.100 | 64 | 6 (TCP) | (L4 데이터 포함) |

### **L4 (전송 계층) - TCP 세그먼트**

L4 계층에서는 데이터를 **TCP 세그먼트**로 처리합니다. 주요 필드는 다음과 같습니다:

- **Source Port**: 송신자의 포트 번호.
- **Destination Port**: 수신자의 포트 번호.
- **Sequence Number**: 데이터 스트림에서의 위치를 나타내는 번호.
- **Acknowledgment Number**: 수신 측에서 확인한 데이터의 다음 위치.
- **Flags**: 제어 정보를 포함합니다 (예: SYN, ACK, FIN).
- **Window Size**: 수신자가 한 번에 받을 수 있는 데이터의 양.
- **Checksum**: 오류 검출을 위한 필드.
- **Payload**: 상위 계층(L7)의 데이터, 즉 HTTP 요청이 이 필드에 포함됩니다.

**예시 데이터프레임 구조 (L4):**

| Source Port | Destination Port | Sequence Number | Acknowledgment Number | Flags | Window Size | Checksum | Payload (L7 데이터) |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 1025 | 80 | 1234567890 | 1234567891 | SYN, ACK | 65535 | (2 bytes) | (HTTP 요청 포함) |

### **종합 예시 - HTTP 요청의 캡슐화**

HTTP 요청이 Wireshark에서 어떻게 L2, L3, L4 계층에서 캡슐화되어 있는지 살펴보겠습니다:

1. **L2 (이더넷 프레임)**
    - 목적지와 출발지 MAC 주소가 포함된 이더넷 프레임이 형성됩니다.
    - 이더넷 프레임은 L3 데이터(IP 패킷)를 포함합니다.
2. **L3 (IP 패킷)**
    - IP 패킷은 목적지와 출발지 IP 주소를 포함합니다.
    - IP 패킷은 L4 데이터(TCP 세그먼트)를 포함합니다.
3. **L4 (TCP 세그먼트)**
    - TCP 세그먼트는 포트 번호, 시퀀스 번호, ACK 번호 등을 포함합니다.
    - TCP 세그먼트는 L7 데이터(HTTP 요청)를 포함합니다.
4. **L7 (애플리케이션 계층)**
    - HTTP 요청은 최종적으로 L4의 TCP 세그먼트에 포함되어 전달됩니다.

각 계층은 위의 데이터 구조를 기반으로 상위 계층의 데이터를 포함하며, 최종적으로 HTTP 요청이 목적지에 도달하게 됩니다.

</aside>

### 스위치의 역할

- L2(Eth)만 확인한다.

### Layer 3 Switch

- IP까지 확인한다.
- 목적지를 안내한다.
- 태생은 스위치이지만 IP까지 확인하도록 확장한 것

### 라우터

- IP를 확인한다. 목적지로 보내줌
- L3 헤더까지 본다.

### L4-L7 Switch SLB 장비

- L4 레벨에서 로드밸런싱 제공하는 스위치

### 케이블 타입

- 1자는 LAN 선 ( ~ 80km)
- 점선은 크로스 케이블
- 번개모양은 WAN 연결(Wide area network) (80km ~ )
- MAN : metroethernet area network

![%ED%99%94%EB%A9%B4_%EC%BA%A1%EC%B2%98_2024-08-19_114933](https://github.com/user-attachments/assets/e2aeeb41-bebd-40fc-ac5c-039c11478d0b)



![%ED%99%94%EB%A9%B4_%EC%BA%A1%EC%B2%98_2024-08-19_115233](https://github.com/user-attachments/assets/72e95f86-ead6-4d91-8faa-c86db0cf90f4)

- 무선 쓰려면 AP가 있어야함.
- AP를 사용하려면 스위치가 있어야한다.
- Switch, Layer 3 Switch, Router 3개는 알아야함.
- Serial Link 선은 WAN

![%ED%99%94%EB%A9%B4_%EC%BA%A1%EC%B2%98_2024-08-19_120706](https://github.com/user-attachments/assets/31dd4437-8c60-45ef-93c8-86da6aa0c396)

- 용어 정리
- Availability : 가용성
- Reliability 안정성
- Scalability 확장성
- QoS → 100 width 대역폭에서 120을 쓴다면 나머지 20은 drop 됨. udp 기반 서비스는 서비스 품질이 떨어짐. 네트워크에서는 QoS를 보장해야한다.

### 실무 토폴로지(고가용성, 안정성, 보안 등등 고려)

![%ED%99%94%EB%A9%B4_%EC%BA%A1%EC%B2%98_2024-08-19_122609](https://github.com/user-attachments/assets/e78415c9-d280-49eb-9fe3-b8cf8a25d949)

### 데이터 vs 보이스 vs 비디오

![%ED%99%94%EB%A9%B4_%EC%BA%A1%EC%B2%98_2024-08-19_122740](https://github.com/user-attachments/assets/71ef1749-0417-46f3-b00b-c1981034f916)


- 데이터는 TCP
- 보이스, 비디오는 레이턴시가 중요하기 때문에 가벼운 UDP 사용
- 문자와 문자사이의 간격이 일정하게 늘어지거나 좁게 들리는 현상이 레이턴시가 낮다.
- 딜레이는 버퍼링 같은 것

<aside>
💡 딜레이(Delay)와 레이턴시(Latency)는 네트워크와 통신에서 자주 언급되는 용어이며, 둘 다 데이터 전송과 관련된 시간 지연을 나타내지만, 그 의미와 사용되는 맥락에는 차이가 있습니다.

### **1. 레이턴시 (Latency)**

레이턴시는 네트워크에서 **데이터 패킷이 출발지에서 목적지까지 도달하는 데 걸리는 시간**을 의미합니다. 즉, 특정 시점에 데이터를 보내기 시작한 순간부터 그 데이터가 목표에 도달할 때까지의 전체 시간을 말합니다.

### **비유:**

레이턴시는 마치 택배 회사가 물건을 당신의 집에서 친구의 집까지 배달하는 데 걸리는 시간이라고 생각할 수 있습니다. 이 시간은 물건이 출발한 순간부터 친구가 물건을 받기까지의 전체 시간입니다. 이 시간은 거리에 따라 달라질 수 있으며, 경로의 혼잡도나 여러 가지 요인에 의해 영향을 받을 수 있습니다.

### **주요 요소:**

- **전송 지연 (Transmission Delay):** 데이터가 전송 매체를 통해 이동하는 시간.
- **전파 지연 (Propagation Delay):** 신호가 네트워크를 통해 이동하는 시간, 주로 물리적 거리와 매체의 특성에 따라 달라집니다.
- **처리 지연 (Processing Delay):** 라우터나 스위치 같은 네트워크 장치가 데이터를 처리하는 데 걸리는 시간.
- **큐잉 지연 (Queuing Delay):** 네트워크 장치에서 데이터가 전송되기 전 대기하는 시간.

### **2. 딜레이 (Delay)**

딜레이는 일반적으로 **어떤 사건이 발생하고 그 결과가 나타나기까지의 시간 지연**을 의미합니다. 네트워크에서는 딜레이라는 용어가 특정한 종류의 지연을 가리키기도 하고, 레이턴시와 비슷한 의미로 사용되기도 합니다. 딜레이는 여러 종류가 있을 수 있으며, 각 네트워크 과정에서 발생하는 지연을 의미할 수 있습니다.

### **비유:**

딜레이는 택배 과정에서 특정한 단계에서 발생하는 지연이라고 할 수 있습니다. 예를 들어, 물건이 포장되는 데 시간이 오래 걸리거나, 택배 트럭이 도로에서 교통체증을 만나는 상황이 발생하면, 각각의 단계에서 딜레이가 발생하는 것입니다.

### **종류:**

- **전송 딜레이 (Transmission Delay):** 데이터가 네트워크 인터페이스를 통해 전송되기 시작하고 끝날 때까지의 시간.
- **프로세싱 딜레이 (Processing Delay):** 데이터를 처리하거나 분석하는 데 걸리는 시간.
- **큐잉 딜레이 (Queuing Delay):** 데이터를 전송하기 위해 대기하는 시간.
- **프로파게이션 딜레이 (Propagation Delay):** 신호가 네트워크 상에서 이동하는 데 걸리는 시간.

### **주요 차이점**

1. **포괄적인 개념 vs. 세부적인 개념**:
    - **레이턴시**는 출발지에서 목적지까지 데이터가 이동하는 데 걸리는 **전체 시간**을 의미하는 포괄적인 개념입니다.
    - **딜레이**는 레이턴시에 포함될 수 있는 여러 **세부적인 시간 지연**을 가리킬 수 있습니다. 즉, 레이턴시를 구성하는 요소들 중 일부 또는 전부를 특정 상황에서 가리킬 수 있습니다.
2. **사용되는 맥락**:
    - 레이턴시는 주로 네트워크 성능을 측정할 때 사용되며, 데이터가 한 지점에서 다른 지점까지 이동하는 데 걸리는 전체 시간을 평가할 때 사용됩니다.
    - 딜레이는 특정한 네트워크 과정에서의 지연을 설명할 때 사용되며, 레이턴시의 구성 요소로 설명될 수 있습니다.

### **요약**

- **레이턴시**: 출발지에서 목적지까지 데이터가 도달하는 데 걸리는 전체 시간을 의미하며, 네트워크에서의 지연을 총체적으로 나타냅니다.
- **딜레이**: 네트워크에서 발생하는 특정한 종류의 지연을 설명하며, 레이턴시의 구성 요소로 작용할 수 있습니다.

이제 딜레이와 레이턴시의 차이점을 이해하셨다면, 추가로 궁금한 부분이나 더 알고 싶은 주제가 있는지 알려주세요!

</aside>

![%ED%99%94%EB%A9%B4_%EC%BA%A1%EC%B2%98_2024-08-19_123551](https://github.com/user-attachments/assets/567cebbd-544b-4e21-a2b2-5a333bff0679)

- PDU 이름 : TCP 세그먼트, IP 패킷, Eth 프레임
- Protocol Data Unit

라우터는 L3까지

스위치는 L2가지 본다

### 게이트웨이

- 다른 대역의 아이피와 통신할 때 사용한다.

### DHCP 서버

- 사용자에게 IP를 자동으로 할당하는 서버(게이트웨이랑 같이 있을 때도 있음)


![%ED%99%94%EB%A9%B4_%EC%BA%A1%EC%B2%98_2024-08-19_141224](https://github.com/user-attachments/assets/b6f4545c-2695-46bf-afa4-178894f1b728)

- 게이트웨이를 통해 DNS에게 주소를 묻고 소스아이피, 데스티네이션 아이피를 받아서 반대편 L3 라우터와 통신하고 외부 서버와 통신한다.

### Cisco nos

- ios, ios xe : enterprise
- ios xr : service provider
- nx-os : data center
- san : storage

CCNA는 전부 ios 기준

### 시스코 장비 초기셋업 CLI

- 스위치 초기셋업 (IP설정)


![%ED%99%94%EB%A9%B4_%EC%BA%A1%EC%B2%98_2024-08-19_142734](https://github.com/user-attachments/assets/496a7850-6d03-408c-a849-1a965c42552e)


![%ED%99%94%EB%A9%B4_%EC%BA%A1%EC%B2%98_2024-08-19_143038](https://github.com/user-attachments/assets/0670f67b-35c0-4ffb-88fd-4046b033f81c)

- enable 명령어 치면 #로 변경
- User exec 모드는 설정만 볼 수있고 실제 설정하려면 enable 모드로 들어가서 configure terminal로 들어가서 설정해야함.
- configure terminal 모드는 트리형태로 어떤 상태로든 이동가능
- #interface f0/1 인터페이스 모드
- en
- conf t
- hostname WooriFIS

### 서브넷팅

8bit 단위로 4자리 255.255.255.255 / 1111 1111. 1111 1111.

서브넷 마스크 16이면

10.0.0.0 / 16

0000 1010. 0000. 0000. 0000 0000. 0000 0000 ←—- 10.0.0.0

1111 1111. 1111 1111. 0000 0000. 0000 0000 ←— 255.255.0.0 (서브넷 16)

### 서브넷팅한 대역대와 통신하고 싶다면 라우팅해야함

- 스위치는 같은 네트웍대에 사용 , IP 필요 x
- 다른 네트웍 통신 라우터 필요.
- 다른 네트웍인지 아는 방법은 서브넷팅으로 알 수 있다.

### 만약에 10개의 호스트만 열거라면 서브넷팅 설계를 어떻게 해야할까?

![%ED%99%94%EB%A9%B4_%EC%BA%A1%EC%B2%98_2024-08-19_154028](https://github.com/user-attachments/assets/3a00b0ec-ddae-43fa-bbc6-4c0a28158373)

![%ED%99%94%EB%A9%B4_%EC%BA%A1%EC%B2%98_2024-08-19_162032](https://github.com/user-attachments/assets/1d874bb8-7d4b-44e8-b765-9c6cf5de185b)


- 192.168.10.0/24 서브넷을 4개로 나누면?

![%ED%99%94%EB%A9%B4_%EC%BA%A1%EC%B2%98_2024-08-19_162310](https://github.com/user-attachments/assets/6f184932-5e3e-42b8-8c84-85370966218b)

- 6층의 네트워크를 서브넷으로 나눌것인가 아니면 하나로 쓸 것인가 결정
- 비용, 보안 다 고려해서
- 다만, 랜섬웨어 같은 공격같은 브로드캐스트 위험환경을 고려하면 서브넷을 나눌것을 지향함

![%ED%99%94%EB%A9%B4_%EC%BA%A1%EC%B2%98_2024-08-19_163301](https://github.com/user-attachments/assets/ae3aff8d-5d79-46df-b6e2-f8cfea3f7c7f)

- 라우터가 VLSM 기법을 지원하지 않는 라우터는 주의해야한다.
- 잘못된 서브넷팅을 전달한다.

<aside>
💡 **VLSM(Variable Length Subnet Mask) 설명**

VLSM(Variable Length Subnet Mask)은 네트워크 서브넷팅에서 서브넷 마스크의 길이를 가변적으로 설정할 수 있는 기법입니다. 이를 통해 네트워크 관리자는 IP 주소 공간을 더욱 효율적으로 사용할 수 있습니다. 기본적으로, VLSM은 동일한 네트워크 내에서 다양한 크기의 서브넷을 만들 수 있게 해줍니다.

### **기본 개념**

- **고정 길이 서브넷 마스크(FLSM)**: 동일한 네트워크 내에서 모든 서브넷이 동일한 크기를 가지도록 하는 서브넷팅 방식입니다. 예를 들어, /24 네트워크를 /26으로 나누면 모든 서브넷은 64개의 IP 주소를 가지게 됩니다. 이 경우 IP 주소가 낭비될 가능성이 높아질 수 있습니다.
- **가변 길이 서브넷 마스크(VLSM)**: 네트워크의 필요에 따라 서브넷 마스크의 길이를 가변적으로 설정하여, 서브넷마다 다른 크기의 IP 주소를 할당할 수 있습니다. 예를 들어, 하나의 서브넷에는 /26 서브넷 마스크를 적용해 64개의 IP 주소를 할당하고, 다른 서브넷에는 /30 서브넷 마스크를 적용해 4개의 IP 주소만 할당할 수 있습니다.

### **VLSM의 장점**

1. **IP 주소의 효율적 사용**: VLSM을 사용하면 필요한 만큼의 IP 주소만 할당할 수 있으므로, IP 주소의 낭비를 줄일 수 있습니다. 작은 네트워크에는 작은 서브넷을, 큰 네트워크에는 큰 서브넷을 할당함으로써 IP 주소 공간을 더 효과적으로 관리할 수 있습니다.
2. **유연한 네트워크 설계**: VLSM을 사용하면 네트워크를 더 유연하게 설계할 수 있습니다. 다양한 크기의 서브넷을 네트워크 구조에 맞게 배치할 수 있어, 네트워크 확장이나 재구성이 용이합니다.
3. **라우팅 테이블 최적화**: VLSM을 사용하면 라우터의 라우팅 테이블 크기를 줄일 수 있습니다. 이는 라우터의 성능 향상과 네트워크 효율성을 높이는 데 기여합니다.

### **VLSM의 작동 방식**

VLSM을 사용하여 서브넷을 나눌 때, 먼저 가장 큰 서브넷을 만들고, 그 다음 작은 서브넷을 만들면서 남은 IP 주소를 사용합니다. 이 과정은 다음과 같습니다:

1. **네트워크 요구사항 분석**: 네트워크의 각 부분이 필요한 IP 주소의 개수를 파악합니다.
2. **서브넷팅**: 가장 큰 서브넷부터 시작해 서브넷팅을 진행합니다. 예를 들어, 100개의 IP 주소가 필요한 네트워크에는 /25 서브넷(128개의 IP 주소)을 할당하고, 작은 네트워크에는 /30 서브넷(4개의 IP 주소)을 할당합니다.
3. **남은 IP 주소 재할당**: 사용되지 않은 남은 IP 주소 범위를 더 작은 서브넷으로 나누어, 필요한 만큼만 할당합니다.

### **VLSM 예제**

예를 들어, `192.168.1.0/24` 네트워크가 있고, 다음과 같은 네트워크 요구사항이 있다고 가정해봅시다:

- 첫 번째 서브넷: 50개의 호스트 필요
- 두 번째 서브넷: 25개의 호스트 필요
- 세 번째 서브넷: 10개의 호스트 필요
- 네 번째 서브넷: 5개의 호스트 필요

### **VLSM 서브넷팅 과정**

1. **첫 번째 서브넷**: 50개의 IP 주소가 필요하므로, /26 서브넷을 사용합니다 (64개의 IP 주소를 제공).
    - 서브넷: `192.168.1.0/26`
    - IP 범위: `192.168.1.0` ~ `192.168.1.63`
2. **두 번째 서브넷**: 25개의 IP 주소가 필요하므로, /27 서브넷을 사용합니다 (32개의 IP 주소를 제공).
    - 서브넷: `192.168.1.64/27`
    - IP 범위: `192.168.1.64` ~ `192.168.1.95`
3. **세 번째 서브넷**: 10개의 IP 주소가 필요하므로, /28 서브넷을 사용합니다 (16개의 IP 주소를 제공).
    - 서브넷: `192.168.1.96/28`
    - IP 범위: `192.168.1.96` ~ `192.168.1.111`
4. **네 번째 서브넷**: 5개의 IP 주소가 필요하므로, /29 서브넷을 사용합니다 (8개의 IP 주소를 제공).
    - 서브넷: `192.168.1.112/29`
    - IP 범위: `192.168.1.112` ~ `192.168.1.119`

이와 같이, VLSM을 사용하면 필요한 크기의 서브넷을 만들어 IP 주소를 효율적으로 사용할 수 있습니다.

### **결론**

VLSM(Variable Length Subnet Mask)은 네트워크에서 IP 주소를 더욱 효율적으로 관리하고, 다양한 크기의 서브넷을 만들기 위해 사용하는 기법입니다. 이를 통해 네트워크 자원을 절약하고, 네트워크 구조를 더 유연하게 설계할 수 있습니다.

더 궁금한 점이나 추가적인 질문이 있다면 언제든지 물어보세요!

</aside>

![%ED%99%94%EB%A9%B4_%EC%BA%A1%EC%B2%98_2024-08-19_163457](https://github.com/user-attachments/assets/47ba84b8-b179-4ed2-9ee6-1db285471d28)

- 클래스별 사설주소
- 공인IP로 변환해주는 NAT를 나중에 라우터에서 사용해주면 외부와 통신가능

### 크로스케이블을 쓸 경우

- 같은 역할을하는 장비를 연결할 때 쓴다.

### 아이피 대역 처음과 끝을 사용 못하는 이유

- 0번째는 그룹 주소임
- 255번째는 브로드캐스트 주소임

### 서브넷팅 문제

![%ED%99%94%EB%A9%B4_%EC%BA%A1%EC%B2%98_2024-08-19_195148](https://github.com/user-attachments/assets/2d04f45f-218b-465f-94c1-b4680fe3f86e)

- 50개의 IP를 4개의 사용자에게 할당해야함.
- 서브넷은 20까지 있는 상태

### 문제 풀이

1. 먼저 50개씩 분배해야하니 2 4 8 16 32 64 최소 2의6승이 필요
2. 서브넷팅 다 찬게 32이니까 거기서 6을 빼면 26이 남음
3. 26은 각 IP를 0~63까지 즉 64만큼 각각 할당해줄 수 있는 서브넷팅임
4. 26을 서브넷팅으로 잡고 각각 나눠주면 다음과 같은 범위가 만들어짐

```jsx
1010 1100 / 0001 0110 / 0010 0000 / 0000 0000 <----- 172.16.32.0
1111 1111 / 1111 1111 / 1111 1111 / 1100 0000 <----- 26
=======
172.16.32.0 ~ 172.16.32.63
172.16.32.64 ~ 172.16.32.127
172.16.32.128 ~ 172.16.32.192
172.16.32.192 ~ 172.16.32.255
```

- 0번과 63번은 예약되어 있어서 사용할 수 없어서 62개의 IP를 사용 가능함. 그러면 50개씩 사용한다고 했을 때 각 12개의 IP가 남음
- 12 x 4 = 총 48개의 IP가 남지만 이게 최선의 서브넷팅임
- 양쪽 라우터에도 각각 IP를 할당해주어야함.
- 그러면 2개의 아이피만 할당하면 될 거 같겠지만 시작, 끝 아이피는 예약이기 때문에 4개가 필요함.
- 32번 대역은 이미 다 사용했기에 33번 사용

```jsx

1010 1100 / 0001 0110 / 0010 0001 / 0000 0000 <----- 172.16.33.0
1111 1111 / 1111 1111 / 1111 1111 / 1111 1100 <----- 30
===============
172.16.33.0 ~ 172.16.33.3
172.16.33.4 ~ 172.16.33.7
172.16.33.8 ~ 172.16.33.11
172.16.33.12 ~ 172.16.33.15
```

- 각 끝단은 사용 못하니 1,2 / 5,6 / 9,10 / 13,14 아이피를 각각 라우터에 적용해서 사용